/* Las librerias que utilizadas en el proyecto se las puede encontrar en https://mvnrepository.com/ 
las cuales se  importan en nustro archivo sbt. Ahora bien nuestro libreria java.io.File la utilizamos para pasar el path,
es decir la direccion de donde se encuentra nuestro archivo csv proporcionado para nuestro proyecto, luego tenemos las librerias
LocalDateTime y DateTimeFormatter que usamos para dar el tipo de dato fecha dias/mes/anio y su uso 
adecuado,como siguiente importamos la libreria Regex para hacer uso de las expresiones regulares 
mediante la instaciacion de un objeto Regex ,tambien tenemos la importacion de Kantan para el tratamiento 
adecuado de nuestro csv, ademas usamos localDateTimeDecoder para poder usar el decodificador para elegir que formato de fecha 
vamos usar, finalmente tenemos ListMap para poder crear una lista que contengas la estructura de mapas (clave-> valor).
*/

import java.io.File
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter
import scala.util.matching.Regex// librerÃ­a para poder usar expresiones regulares
import kantan.csv._
import kantan.csv.ops._
import kantan.csv.generic._
import kantan.csv.java8.localDateTimeDecoder
import scala.collection.immutable.ListMap

// Creamos una una variable que recibe la direccion de nuestro archivo csv
val path2DataFile = "C:\\Users\\harry\\Documents\\David\\PF\\ods_2_3.csv"

// Creamos la la variable formatDateTime que es instanciada por DateTimeFormatter para especificarel formato de fecha
val formatDateTime = DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm:ss")
// Creamos la la variable  patternURL que recibe la expresion regular para encontrar url
val patternURL = new Regex("((http|ftp|https):\\/\\/[\\w\\-_]+(\\.[\\w\\-_]+)+([\\w\\-\\.,@?^=%&amp;:\\/~\\+#]*[\\w\\-\\@?^=%&amp;\\/~\\+#])?)")

// Creamos la la variable  patternURL que recibe la expresion regular para encontrar url
val pattern = new Regex(">.\\w*\\s\\w*\\s\\w*<")

/* En el siguiente bloque de codigo creamos el objeto Tweet con 18 atributos que representan nuestran 18 columnas del csv, con el
fin de manipular con mayor facilidad nuestros datos, como e vera mas adelate en nuestro codigo el uso de tweet.text . */

case class Tweet(
                  idStr: String,
                  fromUser: String,
                  text: String,
                  createdAt: String,
                  time: LocalDateTime,
                  geoCoordinates: String,
                  userLang: String,
                  inReply2UserId: String,
                  inReply2ScreenName: String,
                  fromUserId: String,
                  inReply2StatusId: String,
                  source: String,
                  profileImageURL: String,
                  userFollowersCount: Double,
                  userFriendsCount: Double,
                  userLocation: String,
                  statusURL: String,
                  entitiesURL: String
                )
implicit val decoder : CellDecoder[LocalDateTime] = localDateTimeDecoder(formatDateTime)
val dataSource = new File(path2DataFile).readCsv[List, Tweet](rfc.withHeader)
val values = dataSource.collect({ case Right(tweet) => tweet })
val fromUsersList = values.map(tweet => tweet.fromUser)
println(fromUsersList.toSet.size)

//devuelve una lista con los datos del campo source
val fromSourceList = values.map(tweet=> tweet.source)
val extraccionPWfromSource = fromSourceList.map(x=> pattern.findFirstIn(x))
val desnenvolver:PartialFunction[Any, String] = { case Some(value:String) => value.tail.init}
val namesPagesWebs=extraccionPWfromSource.collect(desnenvolver)
val namesAgrupados =namesPagesWebs.groupBy(identity).map( { case (k,v) => (k,v.length)} )
val namesAOrdenados= ListMap(namesAgrupados.toSeq.sortWith(_._2>_._2): _*)

//devuelve una lista con los datos del campo source
// distribucion de los url's

val fromSourceList2 = values.map(tweet=> tweet.source)
val extraccionURLS = fromSourceList2.map(x=> patternURL.findFirstIn(x))
def desenvolver2:PartialFunction[Any, String] = { case Some(value:String) => value}
val urls =extraccionURLS.collect(desenvolver2)
val namesURLS =urls.groupBy(identity).map( { case (k,v) => (k,v.length)} )
val urlsOrdenados = ListMap(namesURLS.toSeq.sortWith(_._2>_._2): _*)
urlsOrdenados.foreach( println)
